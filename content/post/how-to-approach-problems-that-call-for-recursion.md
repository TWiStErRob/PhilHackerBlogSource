+++
author = ""
comments = true
date = "2016-04-05T17:11:56-04:00"
draft = true
share = true
slug = "how-to-approach-problems-that-call-for-recursion"
tags = ["tag1", "tag2"]
title = "How to approach problems that call for recursion"
+++

#How to approach problems that call for recursion

Recursive processes require more space to evaluate because of the chain of deferred operations, so they are usually not the most elegant solution to a problem that calls for recursion. However, it's often easier to design a procedure that produces an recursive process than it is design one that produces an iterative one. So, when approaching a problem that calls for recursion, it may be best to start by attempting to conjure up a recursive process and from there, working on making that process iterative (or tail-recursive).

The definition of a iterative process in Sicp (pg. 42) suggests a general strategy for doing this.

1. Identify all state variables
1. Identify the rules that describe how those state variables should change from one state to the next.

Completing the first task in the above list may be easier if we:

3. Ask the question: what variables do I need so that the recursive call does not result in any deferred operations?

Deferring an operation within a larger expression is way of storing state, and as such, whenever we see deferred operations, we should suspect there's a state variable waiting to be discovered.

Completing the second task in the above list may be easier if we:

4. Define an invariant quantity that remains unchanged from state to state.

Once we have an invariant quantity, we can ask, what rules are necessary for this quantity to remain unchanged from state to state.

Finally, here's one hint we can keep in mind in implementing our procedure:

5. The base case will probably return an expression that utilizes one of the state variables. In many cases, the base case will simply return one of the state variables (usually called an accumulator).

Here are some examples of how to apply these steps. Suppose we have a recursive process generated by the following procedure:

```
(defn factorial [n]
  (if (= n 1)
    1
    (* n (factorial (dec n)))
    )
  )
```

How do we know we've found all the state variables? The number of state variables we need for a recursive procedure that generates an iterative process is equal to the number of recursive calls + any variables needed to check the base case.

The first thing we notice is that this procedure's recursive call results in deferred operations. Eliminating the deferred operation would require that we define a variable `a` whose value at the end of the iterative process is equal to result of evaluating all deferred operations at the end of a recursive process.

The result of evaluating all deferred operations at the end of the recursive process generated by `(factorial 3)` is this:

```
(* 3 (factorial (dec 3)))
(* 3 2 (factorial (dec 2)))
(* 3 2 1)
```
So, we need a variable whose result will be 6 at the end of the iterative process.

Here's the invariant: a * factorial n

```
(defn factorial-iter [a n]
  (if (= n 1)
    a
    (factorial-iter (* a n) (dec n))
    )
  )
```

>From pgs. 42, 47, 51
