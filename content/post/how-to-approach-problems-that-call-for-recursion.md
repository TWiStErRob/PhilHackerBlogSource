+++
author = ""
comments = true
date = "2016-04-05T17:11:56-04:00"
draft = true
share = true
slug = "how-to-approach-problems-that-call-for-recursion"
tags = ["tag1", "tag2"]
title = "How to approach problems that call for recursion"
+++

#How to approach problems that call for recursion

Recursive processes require more space to evaluate because of the chain of deferred operations, so they are usually not the most elegant solution to a problem that calls for recursion. However, it's often easier to design a procedure that produces an recursive process than it is design one that produces an iterative one. So, when approaching a problem that calls for recursion, it may be best to start by attempting to conjure up a recursive process and from there, working on making that process iterative.

The above definition of a iterative process suggests a general strategy for doing this.

1. Identify all state variables
1. Identify the rules that describe how those state variables should change from one state to the next.

Completing the first task in the above list may be easier if we:

3. Ask the question: what variables do I need so that the recursive call does not result in any deferred operations?

Deferring an operation within a larger expression is way of storing state, and as such, whenever we see deferred operations, we should suspect there's a state variable waiting to be discovered.

Completing the second task in the above list may be easier if we:

4. Define an invariant quantity that remains unchanged from state to state.

Once we have an invariant quantity, we can ask, what rules are necessary for this quantity to remain unchanged from state to state.

Finally, here's one hint we can keep in mind in implementing our procedure:

5. The base case will probably return one of the state variables (usually called the accumulator).

Here's an example of how to apply these steps. Suppose we have a recursive process generated by the following procedure:

```
(defn factorial [n]
  (if (= n 1)
    1
    (* n (factorial (dec n)))
    )
  )
```

Here's the invariant: a * factorial n

```
(defn factorial-iter [a n]
  (if (= n 1)
    a
    (factorial-iter (* a n) (dec n))
    )
  )
```

>From pgs. 42, 47, 51
